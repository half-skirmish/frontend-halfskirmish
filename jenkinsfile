pipeline {
    agent any

    environment {
        KUBECONFIG = "/var/lib/jenkins/.kube/config"  // Path to your kubeconfig file on Jenkins server
        NAMESPACE = "dinara"                          // Namespace where the deployment will occur
    }

    stages {
        stage('Build and Push Docker Image') {
            steps {
                script {
                    // Define variables
                    def imageName = "192.168.1.2:32000/halfskirmish_fes"
                    def dockerfile = ""
                    def imageTag = ""

                    // Determine which Dockerfile and tag to use based on the branch
                    if (env.BRANCH_NAME == 'QualityAssurance') {
                        dockerfile = 'Dockerfile.qa'
                        imageTag = 'qa'
                    } else if (env.BRANCH_NAME == 'Prod') {
                        dockerfile = 'Dockerfile.prod'
                        imageTag = 'prod'
                    } else {
                        error("Unsupported branch: ${env.BRANCH_NAME}")
                    }

                    // Build and push Docker image to the registry
                    docker.withRegistry('http://192.168.1.2:32000') {
                        def dockerImage = docker.build("${imageName}:${imageTag}", "-f ${dockerfile} .")
                        dockerImage.push(imageTag)
                    }

                    // Save imageTag for later use in the pipeline
                    env.IMAGE_TAG = imageTag
                }
            }
        }

        stage('Deploy to Kubernetes') {
            steps {
                script {
                    def imageName = "192.168.1.2:32000/halfskirmish_fes"
                    def manifestsPath = ""

                    // Use the stored imageTag for deployment
                    def imageTag = env.IMAGE_TAG

                    // Determine which manifests to use based on the branch
                    if (env.BRANCH_NAME == 'QualityAssurance') {
                        manifestsPath = 'manifests/QA'
                    } else if (env.BRANCH_NAME == 'Prod') {
                        manifestsPath = 'manifests/prod'
                    }

                    // Update the deployment manifest with the correct image and tag
                    sh """
                    sed -i 's|image:.*|image: ${imageName}:${imageTag}|' ${manifestsPath}/deployment.yaml
                    """

                    // Apply the updated Kubernetes manifests
                    sh """
                    kubectl --kubeconfig=${KUBECONFIG} apply -f ${manifestsPath}/ -n ${NAMESPACE}
                    """
                }
            }
        }

        stage('Force Rolling Restart') {
            steps {
                script {
                    // Conditionally restart based on the branch
                    if (env.BRANCH_NAME == 'QualityAssurance') {
                        sh "kubectl --kubeconfig=${KUBECONFIG} rollout restart deployment/halfskirmish-fes -n ${NAMESPACE}"
                    } else if (env.BRANCH_NAME == 'Prod') {
                        sh "kubectl --kubeconfig=${KUBECONFIG} rollout restart deployment/halfskirmish-fes-prod -n ${NAMESPACE}"
                    } else {
                        error("Unsupported branch: ${env.BRANCH_NAME}")
                    }
                }
            }
        }
    }
}
